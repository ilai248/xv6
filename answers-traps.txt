1. The a0–a7 and fa0–fa7 registers contain arguments to functions (for ints and floats repsectively).
   In our example, the register a0 holds the pointer to the string-to-print, a1 stores the result of f(8)+1 which is statically calculated,
   and a2 stores the number 13.

2. Like I specified above, the call to f and g is cancelled as the compiler automatically calculates the result and sets a1 to 12 (8+3+1).

3. printf is located at address: 1570 + 0x38 = 0x000000000000065a = 0x65a.

4. The value in "ra" just after the jalr to printf is 0x40, which is the return address from printf.

5. The output of the code is "He110 World". if RISC-V was big endian I would have needed to set 'i'
   to 0x726c6400, in order for the chars to printed in the correct order.
   However, 57616 would not need to be changed to another number as we only use its hex representation as it is (0xe110)
   and we don't need to use it as a non-numerical value (or iterate over its bytes in-order like '%s' does).
   This means that if we write 57616 as little endian we also interperet it as little endian, and if we will write it in
   a big endian machine we would read it as big endian and the result wouldn't change.

6. After "y=" the code is going to print the previous value that was saved in a2.
   This happens because we are only overriding a0 and a1 (because we send 2 arguments) and don't override a3.
   When the function tries to print the third argument it will think we still provided the value as a2 and print it instead.